# 进销存管理系统软件详细设计描述文档

## 1. 引言

### 1.1 编制目的

本报告详细完成对进销存系统的详细设计，达到知道后继软件构造的目的，同时实现和测试人员及用户的沟通

### 1.2 词汇表

| 词汇名称          | 词汇含义         | 备注   |
| ------------- | ------------ | ---- |
| presentation  | 展示层          |      |
| businesslogic | 业务逻辑层        |      |
| data          | 数据层          |      |
| PO            | 持久化存储,是外存的抽象 |      |
| VO            | 网络传输,是数据包的抽象 |      |



### 1.3 参考资料

## 2. 产品概述

参考灯具厂进销存系统用例文档和连锁商店管理系统软件需求规格说明文档中对产品的概括描述。

## 3. 体系结构设计概述

参考灯具厂进销存系统概要设计文档中对体系结构设计的概述

## 4. 结构视角

### 4.1 业务逻辑层的分解 

### 4.1.1 categorybl

（1）模块描述

categorybl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

categorybl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加categorylogicservice.categoryblservice.CategoryBLService接口。业务逻辑层和数据层之间添加dataservice.categorydataservice.CategoryDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了CategoryController,这样CategoryController会将对商品分类管理的业务逻辑处理委托给Category对象。CategoryPO是作为商品分类记录的持久化对象被添加到设计模型中去的。

- categorybl模块的设计如下图：

  ![categorybl模块各个类的设计](..\img\categorybl模块各个类的设计.png)

- 表categorybl 模块各个类的职责

|        模块         |                职责                 |
| :---------------: | :-------------------------------: |
|  LoginController  |         负责实现对应于登陆界面所需要的服务         |
| CategoryConroller |         负责实现商品管理界面所需要的服务          |
|       User        | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     Category      |           商品分类管理的领域模型对象           |

（3）模块内部类的接口规范

**CategoryController的接口规范**

**提供的服务<供接口>**

##### **1. CategoryController.addCategory**

##### **语法:**public boolean addCategory(CategoryVO cvo)

##### **前置条件:** 已创建一个Category领域对象，并且符合输入规则

##### 后置条件: 调用Category领域对象的addCategory方法

##### **2. CategoryController.deleteCategory**

##### **语法:**public boolean deleteCategory(CategoryVO cvo)

##### **前置条件:** 已创建一个Category领域对象，并且符合输入规则

##### 后置条件: 调用Category领域对象的deleteCategory方法

##### **3. CategoryController.editCategory**

##### **语法:**public void editCategory(CategoryVO cvo)

##### **前置条件:** 已创建一个Category领域对象，并且符合输入规则

##### 后置条件: 调用Category领域对象的editCategory方法

**需要的服务<需接口>** 

| 服务名  |  服务  |
| :--: | :--: |
|      |      |

**Category的接口规范**

**提供的服务<供接口>**

##### **1. Category.addCategory**

##### **语法:**public boolean addCategory(CategoryVO avo)

##### **前置条件:**启动一个新建商品分类事件

##### **后置条件:**成功添加商品分类信息

##### **2. Category.deleteCategory**

##### **语法:**public boolean deleteCategory(CategoryVO avo)

##### **前置条件:**启动一个删除商品分类事件

##### **后置条件:**成功删除商品分类信息

##### **3. Category.editCategory**

##### **语法:**public boolean editCategory(CategoryVO avo)

##### **前置条件:**启动一个修改商品分类事件

##### **后置条件:**成功修改商品分类信息

**需要的服务<需接口>** 

|                   服务名                    |         服务          |
| :--------------------------------------: | :-----------------: |
| CategoryDataService.insert(CategoryPO po) |      插入单一持久化对象      |
| CategoryDataService.delete(CategoryPO po) |      删除单一持久化对象      |
| CategoryDataService.update(CategoryPO po) |      更新单一持久化对象      |
|   DatabaseeFactory.getCategoryDatabase   | 得到Category数据库的服务的引用 |

（4）业务逻辑层的动态模型

![添加商品分类的顺序图](..\img\添加商品分类的顺序图.png)

![删除商品分类的顺序图](..\img\删除商品分类的顺序图.png)

![修改商品分类的顺序图](..\img\修改商品分类的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.2 goodbl

（1）模块描述

goodbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

goodbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加goodlogicservice.goodblservice.GoodBLService接口。业务逻辑层和数据层之间添加dataservice.gooddataservice.GoodDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了GoodController,这样GoodController会将对商品管理的业务逻辑处理委托给Good对象。GoodPO是作为商品记录的持久化对象被添加到设计模型中去的。

- goobl模块的设计如下图所示：

  ![goodbl模块各个类的设计](..\img\goodbl模块各个类的设计.png)

- 表goodbl 模块各个类的职责

|       模块        |                职责                 |
| :-------------: | :-------------------------------: |
| LoginController |         负责实现对应于登陆界面所需要的服务         |
|  GoodConroller  |         负责实现商品管理界面所需要的服务          |
|      User       | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|      Good       |            商品管理的领域模型对象            |

（3）模块内部类的接口规范

**GoodController的接口规范**

**提供的服务<供接口>**

##### **1. GoodController.addGood**

##### **语法:**public boolean addGood(GoodVO gvo)

##### **前置条件:** 已创建一个Good领域对象，并且符合输入规则

##### 后置条件: 调用Good领域对象的addGood方法

##### **2. GoodController.deleteGood**

##### **语法:**public boolean deleteGood(GoodVO gvo)

##### **前置条件:** 已创建一个Good领域对象，并且符合输入规则

##### 后置条件: 调用Good领域对象的deleteGood方法

##### **3. GoodController.editGood**

##### **语法:**public void editGood(GoodVO gvo)

##### **前置条件:** 已创建一个Good领域对象，并且符合输入规则

##### 后置条件: 调用Good领域对象的editGood方法

##### **4. GoodController.moveGood**

##### **语法:**public boolean moveGood(GoodVO gvo, CategoryVo cvo)

##### **前置条件:** 已创建一个Good领域对象和一个Category领域对象，并且符合输入规则

##### 后置条件: 调用Good领域对象的moveGood方法

##### **5. GoodController.searchGood**

##### **语法:**public boolean searchGood(GoodVO gvo)

##### **前置条件:** 已创建一个Good领域对象，并且符合输入规则

##### 后置条件: 调用Good领域对象的searchGood方法

**需要的服务<需接口>** 

|            服务名             |    服务    |
| :------------------------: | :------: |
| Category.find(String name) | 找到一个商品分类 |

**Good的接口规范**

**提供的服务<供接口>**

##### **1. Good.addGood**

##### **语法:**public ResultMessage addGood(GoodVO gvo)

##### **前置条件:**启动一个新建商品事件

##### **后置条件:**成功添加商品信息

##### **2. Good.deleteGood**

##### **语法:**public ResultMessage deleteGood(GoodVO gvo)

##### **前置条件:**启动一个删除商品事件

##### **后置条件:**成功删除商品信息

##### **3. Good.editGood**

##### **语法:**public ResultMessage editGood(GoodVO gvo)

##### **前置条件:**启动一个修改商品事件

##### **后置条件:**成功修改商品信息

##### **4. Good.moveGood**

##### **语法:**public ResultMessage moveGood(GoodVO gvo, CategoryVo cvo)

##### **前置条件:** 启动一个移动商品事件

##### 后置条件: 成功移动商品

##### **5. Good.searchGood**

##### **语法:**public ResultMessage searchGood(GoodVO gvo)

##### **前置条件:** 启动一个查询商品事件

##### 后置条件: 显示查询到的商品信息

**需要的服务<需接口>** 

|                 服务名                 |          服务           |
| :---------------------------------: | :-------------------: |
| GoodDataService.find(SearchType st) | 根据searchtype查找单一持久化对象 |
|  GoodDataService.insert(GoodPO po)  |       插入单一持久化对象       |
|  GoodDataService.delete(GoodPO po)  |       删除单一持久化对象       |
|  GoodDataService.update(GoodPO po)  |       更新单一持久化对象       |
|   DatabaseFactory.getGoodDatabase   |    得到Good数据库的服务的引用    |

（4）业务逻辑层的动态模型

![添加商品的顺序图](..\img\添加商品的顺序图.png)

![删除商品的顺序图](..\img\删除商品的顺序图.png)

![修改商品信息的顺序图](..\img\修改商品信息的顺序图.png)

![移动商品的顺序图](..\img\移动商品的顺序图.png)

![查找商品的顺序图](..\img\查找商品的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.3 viewbl

（1）模块描述

viewbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

viewbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加viewlogicservice.viewblservice.ViewBLService接口。业务逻辑层和数据层之间添加dataservice.viewdataservice.ViewDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ViewController,这样ViewController会将对库存查看的业务逻辑处理委托给View对象。ViewPO是作为库存查看记录的持久化对象被添加到设计模型中去的。

（3）模块内部类的接口规范

- viewbl模块的设计如下图：

  ![viewbl模块各个类的设计](..\img\viewbl模块各个类的设计.png)

- 表viewbl 模块各个类的职责

|       模块        |                职责                 |
| :-------------: | :-------------------------------: |
| LoginController |         负责实现对应于登陆界面所需要的服务         |
|  ViewConroller  |         负责实现库存查看界面所需要的服务          |
|      User       | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|      View       |            库存查看的领域模型对象            |

**ViewController的接口规范**

**提供的服务<供接口>**

##### **1. ViewController.search_by_period**

##### **语法:**public String[] search_by_period(Period period)

##### **前置条件:** 已存在库存记录，并且符合输入规则

##### 后置条件: 调用View领域对象的search_by_period方法

##### **2. ViewController.check**

##### **语法:**public String[] check()

##### **前置条件:**  当天存在库存记录，并且符合输入规则

##### 后置条件: 调用View领域对象的check方法

##### **3. ViewController.excel**

##### **语法:**public void excel()

##### **前置条件:**  请求到处excel

##### 后置条件: 成功导出excel文件

**需要的服务<需接口>** 

|        服务名        |  服务  |
| :---------------: | :--: |
| Good.find(int id) | 查找商品 |

**View的接口规范**

**提供的服务<供接口>**

##### **1. View.search_by_period**

##### **语法:**public ResultMessage search_by_period(Period period)

##### **前置条件:**启动一个查看库存事件

##### **后置条件:**显示一个时间段里的库存信息

##### **2. View.check**

##### **语法:**public ResultMessage check()

##### **前置条件:**启动一个库存盘点事件

##### **后置条件:**显示当天的库存信息

##### **3. View.excel**

##### **语法:**public ResultMessage excel()

##### **前置条件:**  启动一个导出excel文件事件

##### 后置条件: 成功导出excel文件

**需要的服务<需接口>** 

|                服务名                |       服务        |
| :-------------------------------: | :-------------: |
| ViewDataService.insert(ViewPO po) |    插入单一持久化对象    |
|  DatabaseFactory.getViewDatabase  | 得到View数据库的服务的引用 |

（4）业务逻辑层的动态模型

![search_by_period顺序图](..\img\search_by_period顺序图.png)

![check顺序图](..\img\check顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.4 giftbl

（1）模块描述

giftbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

giftbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加giftlogicservice.giftblservice.GiftBLService接口。业务逻辑层和数据层之间添加dataservice.giftdataservice.GiftDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了GiftController,这样GiftController会将对库存赠送的业务逻辑处理委托给Gift对象。GiftPO是作为赠品记录的持久化对象被添加到设计模型中去的。

- giftbl模块的设计如下图：

  ![giftbl模块各个类的设计](..\img\giftbl模块各个类的设计.png)

- 表giftbl 模块各个类的职责

|       模块        |                职责                 |
| :-------------: | :-------------------------------: |
| LoginController |         负责实现对应于登陆界面所需要的服务         |
|  GiftConroller  |          负责实现库存赠送所需要的服务           |
|      User       | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|      Gift       |            库存赠送的领域模型对象            |

（3）模块内部类的接口规范

**GiftController的接口规范**

**提供的服务<供接口>**

##### **1. GiftController.recommend**

##### **语法:**public String[] recommend()

##### **前置条件:** 已存在商品领域对象，并且符合输入规则

##### 后置条件: 返回符合条件的商品id

##### **2. GiftController.list**

##### **语法:**public ResultMessage list(GiftVo gvo)

##### **前置条件:**  库存管理人员选择某些商品作为赠品

##### 后置条件: 打印提交单据，从库存中暂时减去这些商品

**需要的服务<需接口>** 

|      服务名      |  服务  |
| :-----------: | :--: |
| Good.find(id) | 查找商品 |

**Gift的接口规范**

**提供的服务<供接口>**

##### **1. Gift.recommend**

##### **语法:**public ResultMessage recommend()

##### **前置条件:**启动一个库存赠送事件

##### **后置条件:**显示可以作为赠品的商品

##### **2. Gift.list**

##### **语法:**public ResultMessage list(GiftVo gvo)

##### **前置条件:**启动一个生成赠品事件

##### **后置条件:**打印提交单据，从库存中暂时减去这些商品

**需要的服务<需接口>** 

|                服务名                |       服务       |
| :-------------------------------: | :------------: |
| GiftDataService.insert(GiftPO po) |   插入单一持久化对象    |
|  DatabaseFactory.getGiftDatabase  | 得到Gift数据库服务的引用 |

（4）业务逻辑层的动态模型

![库存赠送的顺序图](..\img\库存赠送的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.5 supervisebl

（1）模块描述

supervisebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

supervisebl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加superviselogicservice.superviseblservice.SuperviseBLService接口。业务逻辑层和数据层之间添加dataservice.supervisedataservice.SuperviseDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SuperviseController,这样SuperviseController会将对库存监管的业务逻辑处理委托给Supervise对象。SupervisePO是作为库存监管记录的持久化对象被添加到设计模型中去的。

- supervisebl模块的设计如下图所示：

  ![supervisebl模块各个类的设计](..\img\supervisebl模块各个类的设计.png)

- 表supervisebl 模块各个类的职责

|         模块         |                职责                 |
| :----------------: | :-------------------------------: |
|  LoginController   |         负责实现对应于登陆界面所需要的服务         |
| SuperviseConroller |         负责实现库存监管界面所需要的服务          |
|        User        | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     Supervise      |            库存监管的领域模型对象            |

（3）模块内部类的接口规范

**SuperviseController的接口规范**

**提供的服务<供接口>**

##### **1. SuperviseController.overflow**

##### **语法:**public ResultMessage overflow(GoodVo gvo)

##### **前置条件:** 已创建商品领域对象，并且符合输入规则

##### 后置条件: 调用Supervise领域对象的overflow方法

##### **2. SuperviseController.loss**

##### **语法:**public ResultMessage loss(GoodVo gvo)

##### **前置条件:**  已创建商品领域对象，并且符合输入规则

##### 后置条件: 调用Supervise领域对象的loss方法

##### **3. SuperviseController.alert**

##### **语法:**public ResultMessage alert(GoodVo gvo)

##### **前置条件:**  当天存在库存记录，并且符合输入规则

##### 后置条件: 调用Supervise领域对象的alert方法

**需要的服务<需接口>** 

|        服务名         |   服务   |
| :----------------: | :----: |
| Good.find(int id)  |  查找商品  |
| Good.edit(int num) | 修改商品信息 |

**Supervise的接口规范**

**提供的服务<供接口>**

##### **1. Supervise.overflow**

##### **语法:**public ResultMessage overflow(GoodVo gvo)

##### **前置条件:**启动一个库存报溢事件

##### **后置条件:**生成库存报溢单，提交审批

##### **2. Supervise.loss**

##### **语法:**public ResultMessage loss(GoodVo gvo)

##### **前置条件:**启动一个库存报损事件

##### **后置条件:**生成库存报损单，提交审批

##### **3. Supervise.alert**

##### **语法:**public ResultMessage alert(GoodVo gvo)

##### **前置条件:**启动一个库存报警事件

##### **后置条件:**生成库存报警单，提交审批

**需要的服务<需接口>** 

|                   服务名                    |         服务          |
| :--------------------------------------: | :-----------------: |
| SuperviseDataService.insert(SupervisePO po) |      插入单一持久化对象      |
|   DatabaseFactory.getSuperviseDatabase   | 得到Supervise数据库服务的引用 |

（4）业务逻辑层的动态模型

![库存报溢的顺序图](..\img\库存报溢的顺序图.png)

![库存报损的顺序图](..\img\库存报损的顺序图.png)

![库存报警的顺序图](..\img\库存报警的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.6 clientbl

（1）模块描述

clientbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

clientbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加clientblService接口。业务逻辑层和数据层之间添加dataservice.clientdataservice.ClientDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ClientController,这样ClientController会将对库存监管的业务逻辑处理委托给Client对象。ClientPO是作为库存监管记录的持久化对象被添加到设计模型中去的。

##### clientbl模块的接口规范

**提供的服务<供接口>**

##### **1. Client.addClient**

##### **语法:**public ResultMessage addClient(ClientVO cvo)

##### **前置条件:**启动一个销售/进货回合，且原表中用户信息不存在

##### **后置条件:**成功添加用户信息

##### **2.Client.deleteClient **

##### **语法:**public ResultMessage deleteClient(int id)

##### **前置条件:**与客户结束交易过程，应收/应付清算完成，且原表中用户信息存在

##### **后置条件:**用户信息成功删除

##### **3.Client.updateClient **

##### **语法:**public ResultMessage updateClient(ClientVO cvo)·1

##### **前置条件:**修改值合法

##### **后置条件:**用户信息修改成功

##### **4.Client.findClient **

##### **语法:**public ClientVO[] updateClient(int id)

##### **前置条件:**用户id存在

##### **后置条件:**返回对应id用户信息

**需要的服务<需接口>**

| 服务名                                   | 服务                 |
| ------------------------------------- | ------------------ |
| ClientDataService.newClient(ClientPO) | 向数据库插入客户信息         |
| ClientDataService.deleteClient        | 从数据库中移除客户相关信息（假移除） |
| ClientDataService.updateClient        | 修改用户信息             |
| ClientDataService.findClient          | 查找用户信息             |

​    （3）模块内部类的接口规范





![clientbl模块各个类的设计](..\img\clientbl模块各个类的设计.png)















































（4）业务逻辑层的动态模型

![新建客户的顺序图](..\img\新建客户的顺序图.png)

### 4.1.7 importbl

（1）模块描述

importbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

importbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加importblservice.ImportBLService接口。业务逻辑层和数据层之间添加dataservice.importdataservice.ImportDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ImportController,这样ImportController会将对库存监管的业务逻辑处理委托给Import对象。ImportFormPO是作为库存监管记录的持久化对象被添加到设计模型中去的。

##### importbl模块的接口规范

##### **1.Import.newFrom**

##### **语法:**public ResultMessage newFrom(ImportFormVO ifvo)

##### **前置条件:**用户具有权限

##### **后置条件:**生成新表单

##### **2.Import.findFrom**

##### **语法:**public ImportFormVO[] findFrom(String orderid)

##### **前置条件:**表单信息存在

##### **后置条件**:返回订单信息

##### **3.Import.confirm**

##### **语法:**public ResultMessage confirm(String id)

##### **前置条件:**表单存在且未被提交

##### **后置条件**:订单条件设置为待审批

##### **4.Import.cancel**

##### **语法:**public ResultMessage confirm(String id)

##### **前置条件:**表单存在且未被提交

##### **后置条件**:删除

需要的服务<需接口>

| 服务名                          | 服务      |
| ---------------------------- | ------- |
| ImportDataService.newForm    | 插入进货表单  |
| ImportDataService.findForm   | 查询进货单   |
| ImportDataService.updateForm | 更新订货单信息 |

#####  （3）模块内部类的接口规范

![importbl模块各个类的设计](..\img\importbl模块各个类的设计.png)

##### （4）业务逻辑层的动态模型

![新建进货单单的顺序图](..\img\新建进货单单的顺序图.png)

### 4.1.8 salebl

（1）模块描述

importbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

importbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加importblservice.ImportBLService接口。业务逻辑层和数据层之间添加dataservice.importdataservice.ImportDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ImportController,这样ImportController会将对库存监管的业务逻辑处理委托给Import对象。ImportFormPO是作为库存监管记录的持久化对象被添加到设计模型中去的。

##### salebl模块的接口规范

##### **1.Sale.newForm**

##### **语法:**public ResultMessage newFrom(SaleFormVO sfvo)

##### **前置条件:**表单信息存在

##### **后置条件**:返回订单信息

##### **2.Sale.findForm**

##### **语法:**public SaleFormVO[] newFrom(String id)

##### **前置条件:**表单信息存在

##### **后置条件**:返回订单信息

##### **3.Sale.confirm**

##### **语法:**public ResultMessage confirm(String id)

##### **前置条件:**表单存在且未被提交

##### **后置条件**:订单条件设置为待审批

##### **4.Sale.cansel**

##### **语法:**public ResultMessage cansel(String id)

##### **前置条件:**表单存在且未被提交

##### **后置条件**:订单条件设置为待审批

**需要的服务<需接口>** 

|            服务名             |   服务    |
| :------------------------: | :-----: |
|  SaleDataService.findForm  |  查询销售单  |
|  SaleDataService.newForm   | 插入销售表单  |
| SaleDataService.updateForm | 更新销售单信息 |

#####  （3）模块内部类的接口规范

![salebl模块各个类的设计](..\img\salebl模块各个类的设计.png)

（4）业务逻辑层的动态模型

![新建销售单的顺序图](..\img\新建销售单的顺序图.png)

### 4.1.9 accountbl

（1）模块概述

accountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

accountbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.accountblservice.AccountBLService接口。业务逻辑层和数据层之间添加dataservice.accountdataservice.AccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了AccountController,这样AccountController会将对销售的业务逻辑处理委托给Account对象。AccountPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表accountbl 模块各个类的职责

|        模块        |                    职责                    |
| :--------------: | :--------------------------------------: |
| LoginController  |            负责实现对应于登陆界面所需要的服务             |
| AccountConroller |             负责实现账户管理界面所需要的服务             |
|       User       |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|     Account      | 账户管理的领域模型对象，拥有账户名称、余额信息，可以帮助完成账户管理界面所需要的服务。 |

（3）模块内部类的接口规范

![accountbl模块各个类的设计](..\img\accountbl模块各个类的设计.png)

**AccountController的接口规范**

**提供的服务<供接口>**

##### **1. AccountController.addAccount**

##### **语法:**public ResultMessage addAccount(AccountVO avo)

##### **前置条件:** 已创建一个Account领域对象，并且符合输入规则

##### 后置条件: 调用Account领域对象的addAccount方法

##### **2. AccountController.delAccount**

##### **语法:**publicb ResultMessage delAccount(String name)

##### **前置条件:**已创建一个Account领域对象，且账户name存在

##### **后置条件:**调用Account领域对象的delAccount方法

##### **3. AccountController.findAccount**

##### **语法:**public AccountVO[] findAccount(String name)

##### **前置条件:**已创建一个Account领域对象,且查询账户name存在

##### **后置条件:**调用Account领域对象的findAccount方法

##### **4. AccountController.updateAccount**

##### **语法:**public ResultMessage updateAccount(AccountVO avo)

##### **前置条件:**已创建一个Account领域对象，并且符合输入规则

##### **后置条件:**调用Account领域对象的updateAccount方法

**需要的服务<需接口>** 

|                 服务名                  |   服务   |
| :----------------------------------: | :----: |
|  Account.addAccount(AccountVO avo)   | 加入一个账户 |
|   Account.delAccount(String name)    | 删除指定账户 |
|   Account.findAccount(String name)   | 查找指定账户 |
| Account.updateAccount(AccountVO avo) | 修改账户信息 |

**Account的接口规范**

**提供的服务<供接口>**

##### **1. Account.addAccount**

##### **语法:**public ResultMessage addAccount(AccountVO avo)

##### **前置条件:**启动一个新建账户事件

##### **后置条件:**成功添加账户信息

##### **2. Account.delAccount**

##### **语法:**publicb ResultMessage delAccount(String name)

##### **前置条件:**账户name存在

##### **后置条件:**成功删除账户信息

##### **3. Account.findAccount**

##### **语法:**public AccountVO[] findAccount(String name)

##### **前置条件:**查询账户name存在

##### **后置条件:**返回对应name账户信息

##### **4. Account.updateAccount**

##### **语法:**public ResultMessage updateAccount(AccountVO avo)

##### **前置条件:**修改值合法

##### **后置条件:**账户信息修改成功

**需要的服务<需接口>** 

|                   服务名                   |       服务        |
| :-------------------------------------: | :-------------: |
|  AccountDataService.find(String name)   | 根据名称进行查找单一持久化对象 |
| AccountDataService.insert(AccountPo po) |    插入单一持久化对象    |
| AccountDataService.delete(AccountPo po) |    删除单一持久化对象    |
| AccountDataService.update(AccountPo po) |    更新单一持久化对象    |

（4）业务逻辑层的动态模型

![添加账户的顺序图](..\img\添加账户的顺序图.png)

![删除账户的顺序图](..\img\删除账户的顺序图.png)

![查找账户的顺序图](..\img\查找账户的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.10 billbl

（1）模块概述

billbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

billbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.billblservice.BillBLService接口。业务逻辑层和数据层之间添加dataservice.billdataservice.BillDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BillController,这样BillController会将对销售的业务逻辑处理委托给Bill对象。BillPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表billbl 模块各个类的职责

|       模块        |                    职责                    |
| :-------------: | :--------------------------------------: |
| LoginController |            负责实现对应于登陆界面所需要的服务             |
|  BillConroller  |             负责实现财务管理界面所需要的服务             |
|      User       |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|      Bill       | 财务管理的领域模型对象，拥有财务类数据的单据编号、操作员、清单、总额等，可以帮助完成财务管理界面所需要的服务。 |

（3）模块内部类的接口规范

![billbl模块各个类的设计](..\img\billbl模块各个类的设计.png)

##### BillController模块的接口规范

##### **提供的服务<供接口>**

##### 1. BillController.newReceipt

##### **语法:**public ResultMessage newReceipt(ReceiptVO rvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:** 调用Bill领域对象的newReceipt方法

##### **2.BillController.newPayment**

##### **语法:**public ResultMessage newPayment(PaymentVO pvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:**调用Bill领域对象的newPayment方法

##### **3. BillController.newCash**

##### **语法:**public ResultMessage newCash(CashVO cvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:**调用Bill领域对象的newCash方法

**4. BillController.changeState**

##### **语法:**public ResultMessage changeState(String id)

##### **前置条件:** 已创建一个Bill领域对象，且查询id存在

##### **后置条件:** 调用Bill领域对象的changeState方法

**需要的服务<需接口>** 

|              服务名               |   服务    |
| :----------------------------: | :-----: |
| Bill.newReceipt(ReceiptVO rvo) |  创建收款单  |
| Bill.newReceipt(PaymentVO pvo) |  创建付款单  |
|    Bill.newCash(CashVO cvo)    | 创建现金费用单 |
|  Bill.changeState(String id)   | 修改单据状态  |

##### billbl模块的接口规范

##### **提供的服务<供接口>**

##### 1. Bill.newReceipt

##### **语法:**public ResultMessage newReceipt(ReceiptVO rvo)

##### **前置条件:**启动一个生成收款单事件

##### **后置条件:**收款单创建成功

##### **2. Bill.newReceipt**

##### **语法:**public ResultMessage newPayment(PaymentVO pvo)

##### **前置条件:**启动一个生成付款单事件

##### **后置条件:**付款单创建成功

##### **3. Bill.newCash**

##### **语法:**public ResultMessage newCash(CashVO cvo)

##### **前置条件:**启动一个生成现金费用单事件

##### **后置条件:**现金费用单创建成功

**4. Bill.changeState**

##### **语法:**public ResultMessage changeState(String id)

##### **前置条件:** 单据Id合法

##### **后置条件:** 将该单据的审批状态改为待审批

**需要的服务<需接口>** 

|                服务名                |    服务     |
| :-------------------------------: | :-------: |
| BillDataService.insert(BillPo po) | 插入单一持久化对象 |
| BillDataService.delete(BillPo po) | 删除单一持久化对象 |
| BillDataService.update(BillPo po) | 更新单一持久化对象 |

（4）业务逻辑层的动态模型

![新建收款单的顺序图](..\img\新建收款单的顺序图.png)

![新建付款单的顺序图](..\img\新建付款单的顺序图.png)

![新建现金费用单的顺序图](..\img\新建现金费用单的顺序图.png)

![改变单据状态顺序图](..\img\改变单据状态顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.11 initialAccountbl

（1）模块概述

initialAccountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

initialAccountbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.initialAccountblservice.InitialAccountBLService接口。业务逻辑层和数据层之间添加dataservice.initialAccountdataservice.InitialAccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了InitialAccountController,这样InitialAccountController会将对销售的业务逻辑处理委托给InitialAccount对象。InitialAccountPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表initialAccountbl 模块各个类的职责

|           模块            |                    职责                    |
| :---------------------: | :--------------------------------------: |
|     LoginController     |            负责实现对应于登陆界面所需要的服务             |
| InitialAccountConroller |             负责实现期初建账界面所需要的服务             |
|          User           |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|     InitialAccount      | 期初建账的领域模型对象，拥有期初建账数据的商品信息、最近进价和最近售价、客户信息、银行账户信息，可以帮助完成期初建账界面所需要的服务。 |

（3）模块内部类的接口规范

![InitialAccountbl模块各个类的设计](..\img\InitialAccountbl模块各个类的设计.png)

##### InitialAccountConroller的接口规范

**提供的服务<供接口>**

##### 1. InitialAccountConroller.newStage

##### **语法:**public ResultMessage newStage(InitialAccountVO ivo)

##### **前置条件:** 已创建一个InitialAccount领域对象，并且符合输入规则

##### **后置条件:** 用InitialAccount领域对象的newStage方法

##### **2.InitialAccountConroller.inquireStage**

##### **语法:**public ResultMessage inquireStage(Datatime datatime)

##### **前置条件:**  已创建一个InitialAccount领域对象，并且符合输入规则

##### **后置条件:**  调用InitialAccount领域对象的inquireStage方法

**需要的服务<需接口>** 

|                   服务名                    |      服务      |
| :--------------------------------------: | :----------: |
| InitialAccount.newStage(InitialAccountVO ivo) |    新建期初建账    |
| InitialAccount.inquireStage(Datatime datatime) | 查询时间段内期初建账信息 |

##### initialAccountbl的接口规范

**提供的服务<供接口>**

##### 1. InitialAccount.newStage

##### **语法:**public ResultMessage newStage(InitialAccountVO ivo)

##### **前置条件:** 启动一个期初建账事件

##### **后置条件:** 显示期初建账成功

##### **2. InitialAccount.inquireStage**

##### **语法:**public ResultMessage inquireStage(Datatime datatime)

##### **前置条件:**  时间段合法

##### **后置条件:**  显示该时间段内期初建账信息

**需要的服务<需接口>** 

|                   服务名                    |       服务        |
| :--------------------------------------: | :-------------: |
| InitialAccountDataService.find(String id) | 根据id进行查找单一持久化对象 |
| InitialAccountDataService.insert(InitialAccountPo po) |    插入单一持久化对象    |
| InitialAccountDataService.delete(InitialAccountPo po) |    删除单一持久化对象    |
| InitialAccountDataService.update(InitialAccountPo po) |    更新单一持久化对象    |

（4）业务逻辑层的动态模型

![新建期初建账的顺序图](..\img\新建期初建账的顺序图.png)

![查询期初建账的顺序图](..\img\查询期初建账的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.12businessProcessbl

（1）模块概述

businessProcessbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

businessProcessbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.businessProcessblservice.BusinessProcessBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BusinessProcessController,这样BusinessProcessController会将对销售的业务逻辑处理委托给BusinessProcess对象。

- 表BusinessProcessbl 模块各个类的职责

|            模块            |                职责                 |
| :----------------------: | :-------------------------------: |
|     LoginController      |         负责实现对应于登陆界面所需要的服务         |
| BusinessProcessConroller |        负责实现经营历程查询界面所需要的服务         |
|           User           | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     BusinessProcess      | 账户管理的领域模型对象，可以帮助完成经营历程查询界面所需要的服务。 |

（3）模块内部类的接口规范

![BusinessProcess模块各个类的设计](..\img\BusinessProcess模块各个类的设计.png)

**BusinessProcessConroller模块的接口规范** 

##### **1. BusinessProcessConroller.inquire**

##### **语法:**public ResultMessage inquire(Searchtype type)

##### **前置条件:**已创建一个BusinessProcess领域对象，并且符合输入规则

##### **后置条件:**调用BusinessProcess领域对象的inquire方法

**2. BusinessProcessConroller.showDetail**

##### **语法:** public FormVo showDetail(String id)

##### **前置条件:**  已创建一个BusinessProcess领域对象，并且符合输入规则

##### **后置条件:** 调用BusinessProcess领域对象的showDetail方法

**3.BusinessProcessConroller.testIdentity**

##### **语法:** public ResultMessage testIdentity(Usertype type)

##### **前置条件:**  已创建一个BusinessProcess领域对象，并且符合输入规则

##### **后置条件:**  调用BusinessProcess领域对象的testIdentity方法

**4. BusinessProcessConroller.copy**

##### **语法:** public FormVo copy(String id)

##### **前置条件:**  已创建一个BusinessProcess领域对象，并且符合输入规则

##### **后置条件:**  调用BusinessProcess领域对象的copy方法

**5. BusinessProcessConroller.red**

##### **语法:** public FormVo red(String id)

##### **前置条件:**  已创建一个BusinessProcess领域对象，并且符合输入规则

##### **后置条件:**  调用BusinessProcess领域对象的red方法

**需要的服务<需接口>** 

|                   服务名                    |      服务      |
| :--------------------------------------: | :----------: |
| BusinessProcess.inquire(Searchtype type) |  根据条件查询经营历程  |
|  BusinessProcess.showDetail(String id)   | 根据Id显示单据详细信息 |
| BusinessProcess.testIdentity(Usertype type) |    检测用户类型    |
|     BusinessProcess.copy(String id)      |  对表单进行复制操作   |
|      BusinessProcess.red(String id)      |  对表单进行红冲操作   |

**businessProcessbl模块的接口规范** 

##### **1. BusinessProcess.inquire**

##### **语法:**public ResultMessage inquire(Searchtype type)

##### **前置条件:**查询条件合法

##### **后置条件:**显示符合筛选条件的单据

**2. BusinessProcess.showDetail**

##### **语法:** public FormVo showDetail(String id)

##### **前置条件:**  单据id合法

##### **后置条件:**  显示该单据的详细信息

**3. BusinessProcess.testIdentity**

##### **语法:** public ResultMessage showDetail(Usertype type)

##### **前置条件:**  用户类型合法

##### **后置条件:**  显示该用户是否有权限执行红冲操作

**4. BusinessProcess.copy**

##### **语法:** public FormVo copy(String id)

##### **前置条件:**  单据id合法

##### **后置条件:**  复制该单据提供给用户

**5. BusinessProcess.red**

##### **语法:** public FormVo copy(String id)

##### **前置条件:**  单据id合法

##### **后置条件:**  将该单据的金额数据取负数返回给用户

**需要的服务<需接口>** 

|                  服务名                  |       服务        |
| :-----------------------------------: | :-------------: |
|  SaleDataService.findForm(String id)  | 根据id进行查找单一持久化对象 |
|    BillDataService.find(String id)    | 根据id进行查找单一持久化对象 |
| ImportDataService.findForm(String id) | 根据id进行查找单一持久化对象 |

（4）业务逻辑层的动态模型

![经营历程查询的顺序图](..\img\经营历程查询的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.13 translationSituationbl

（1）模块概述

translationSituationbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

translationSituationbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.translationSituationblservice.TranslationSituationBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了TranslationSituationController,这样TranslationSituationController会将对销售的业务逻辑处理委托给TranslationSituation对象。

- 表translationSituationbl 模块各个类的职责

|               模块                |                职责                 |
| :-----------------------------: | :-------------------------------: |
|         LoginController         |         负责实现对应于登陆界面所需要的服务         |
| TranslationSituationblConroller |        负责实现经营情况查询界面所需要的服务         |
|              User               | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     TranslationSituationbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

（3）模块内部类的接口规范

 ![TranslationSituation模块各个类的设计](..\img\TranslationSituation模块各个类的设计.png)

##### TranslationSituationController模块的接口规范

##### **提供的服务<供接口>**

**1.TranslationSituationController.query**

##### **语法:** public ResultMessage query()

##### **前置条件:**  已创建一个TranslationSituation领域对象

##### **后置条件:**  显示交易情况

**2.TranslationSituationController.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 调用TranslationSituation领域对象的end方法

**需要的服务<需接口>** 

|            服务名             |      服务      |
| :------------------------: | :----------: |
| TranslationSituation.query | 查询一段时间内的经营情况 |
|  TranslationSituation.end  |   结束此次查询回合   |

##### TranslationSituation 模块的接口规范

##### **提供的服务<供接口>**

**1.TranslationSituation.query**

##### **语法:** public ResultMessage query()

##### **前置条件:**  无

##### **后置条件:**  显示交易情况

**2.TranslationSituation.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 结束此次查询回合

**需要的服务<需接口>** 

|                   服务名                    |    服务     |
| :--------------------------------------: | :-------: |
|        SaleDataService.findAll()         | 查找所有持久化对象 |
| TranslationSituationDataService.findAll() | 查找所有持久化对象 |
|       ImportDataService.findAll()        | 查找所有持久化对象 |

（4）业务逻辑层的动态模型

 ![TranslationSituation_query顺序图](..\img\TranslationSituation_query顺序图.png)

![TranslationSituation状态图](..\img\TranslationSituation状态图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.14 saleSituationbl

（1）模块概述

saleSituationbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

saleSituationbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.saleSituationblservice.SaleSituationBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SaleSituationController,这样SaleSituationController会将对销售的业务逻辑处理委托给SaleSituation对象。

- 表saleSituationbl模块各个类的职责

|            模块            |                职责                 |
| :----------------------: | :-------------------------------: |
|     LoginController      |         负责实现对应于登陆界面所需要的服务         |
| SaleSituationblConroller |        负责实现经营情况查询界面所需要的服务         |
|           User           | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     SaleSituationbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

（3）模块内部类的接口规范

![SaleSituation模块各个类的设计](..\img\SaleSituation模块各个类的设计.png)

**SaleSituationController模块的接口规范**

##### **提供的服务<供接口>**

**1.SaleSituationController.query**

##### **语法:** public List<SaleSituation> query(SaleSituationVo saleSituationVo)

##### **前置条件:**  已创建了一个SaleSituation领域对象，并且输入符合输入规则

##### **后置条件:**  调用SaleSituation领域对象的query方法

**2.SaleSituationController.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 调用SaleSituation领域对象的end方法

**需要的服务<需接口>** 

|         服务名         |      服务      |
| :-----------------: | :----------: |
| SaleSituation.query | 查询一段时间内的经营情况 |
|  SaleSituation.end  |   结束此次查询回合   |

##### 

##### SaleSituation 模块的接口规范

##### **提供的服务<供接口>**

**1.SaleSituation.List**

##### **语法:** public List<SaleSituation> query(SaleSituationVo saleSituationVo)

##### **前置条件:**  查询条件合法

##### **后置条件:**  显示符合条件的销售明细

**2.SaleSituation.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 结束此次查询回合

**需要的服务<需接口>** 

|                   服务名                    |       服务       |
| :--------------------------------------: | :------------: |
|        SaleDataService.findAll()         |   查找所有持久化对象    |
| SaleSituationDataService.findForList(SaleSituationVo saleSituationVo) | 查找所有符合条件的持久化对象 |
|        BillDataService.findAll()         |   查找所有持久化对象    |
|       ImportDataService.findAll()        |   查找所有持久化对象    |

（4）业务逻辑层的动态模型

![SaleSituation_query顺序图](..\img\SaleSituation_query顺序图.png)

![SaleSituatio状态图](..\img\SaleSituatio状态图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.15 promotionbl

（1）模块概述

promotionbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

promotionbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.promotionblservice.PromotionBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PromotionController,这样PromotionController会将对销售的业务逻辑处理委托给Promotion对象。

- 表translationSituationbl 模块各个类的职责

|          模块          |                职责                 |
| :------------------: | :-------------------------------: |
|   LoginController    |         负责实现对应于登陆界面所需要的服务         |
| PromotionblConroller |        负责实现经营情况查询界面所需要的服务         |
|         User         | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     Promotionbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

（3）模块内部类的接口规范

![Promotion模块各个类的设计](..\img\Promotion模块各个类的设计.png)

**PromotionController模块的接口规范**

##### **提供的服务<供接口>**

**1.PromotionController.makePromotion**

##### **语法:** public ResultMessage makePromotion(PromotionVO promotionVo)

##### **前置条件:**  已创建了一个Promotion领域对象，启动一个制定促销策略回合

##### **后置条件:**  调用Promotion领域对象的makePromotion方法

**2.PromotionController.endPromotion**

##### **语法:** public ResultMessage endPromotion()

##### **前置条件:**  已经制定了一个销售策略

##### **后置条件:** 调用Promotion领域对象的end方法

**需要的服务<需接口>** 

|           服务名           |      服务      |
| :---------------------: | :----------: |
| Promotion.makePromotion |    制订销售策略    |
| Promotion.endPromotion  | 结束此次制订销售策略过程 |

##### Promotion 模块的接口规范

**提供的服务<供接口>**

**1. Promotion.makePromotion**

##### **语法:**public ResultMessage makePromotion(PromotionVO promotionVo)

##### **前置条件:**启动一个制定促销策略回合

##### **后置条件:**成功制定促销策略，持久化更新涉及的领域对象的数据

**2. Promotion.endPromotion**

##### **语法:** public void endPromotion()

##### **前置条件:** 已经制定了一个销售策略

##### **后置条件:** 结束此次制定促销策略回合

**需要的服务<需接口>** 

|                   服务名                    |    服务     |
| :--------------------------------------: | :-------: |
| PricePromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| PricePromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| PricePromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
|   PricePromotionDataService.findAll()    | 查找全部持久化对象 |
| CommodityPromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| CommodityPromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| CommodityPromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
| CommodityPromotionDataService.finaAll()  | 查找全部持久化对象 |
| UserClassPromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| UserCalssPromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| UserClassPromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
| UserClassPromotionDataService.findAll()  | 查找全部持久化对象 |

（4）业务逻辑层的动态模型

![Promotion_makePromotion顺序图](..\img\Promotion_makePromotion顺序图.png)

![Promotion状态图](..\img\Promotion状态图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。



### 4.1.16 approvebl

（1）模块概述

approvebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

approvebl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.approveblservice.ApproveblBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ApproveblController,这样ApproveblController会将对销售的业务逻辑处理委托给Approvebl对象。

- 表approvebl 模块各个类的职责

|         模块         |                职责                 |
| :----------------: | :-------------------------------: |
|  LoginController   |         负责实现对应于登陆界面所需要的服务         |
| ApproveblConroller |        负责实现经营情况查询界面所需要的服务         |
|        User        | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|    Approveblbl     | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

（3）模块内部类的接口规范

![Approve模块各个类的设计](..\img\Approve模块各个类的设计.png)

**ApproveController模块的接口规范**

##### **提供的服务<供接口>**

**1.ApproveController.getApplication**

##### **语法:** public void getApplication()

##### **前置条件:** 已创建一个Approve领域对象，启动一个审批单据的回合

##### **后置条件:** 调用Approve领域对象的getApplication方法

**2. ApproveController.approveApplication**

##### **语法:** public void approveApplication()

##### **前置条件:** 已创建一个Approve领域对象，获取了所有的申请单据

##### **后置条件:** 调用Approve领域对象的approveApplication方法

**3. ApproveController.sendMessage**

##### **语法:** public void sendMessage()

##### **前置条件:** 已创建一个Approve领域对象，单据审批已通过

##### **后置条件:** 调用Approve领域对象的sendMessage方法

**4. ApproveController.endApplication**

##### **语法:** public void endPromotion()

##### **前置条件:** 已创建一个Approve领域对象

##### **后置条件:** 调用Approve领域对象的endApplication

**需要的服务<需接口>** 

|            服务名             |        服务         |
| :------------------------: | :---------------: |
|   Approve.getApplication   |    得到所有的审批状态单据    |
| Approve.approveApplication |       审批单据        |
|    Approve.sendMessage     | 给库存管理员发送一条审批通过的消息 |
|   Approve.endApplication   |    结束此次审批单据的回合    |

##### 

**Approve 模块的接口规范**

**提供的服务<供接口>**

**1.Approve.getApplication**

##### **语法:** public void getApplication()

##### **前置条件:** 启动一个审批单据的回合

##### **后置条件:** 返回所有申请单据

**2. Approve.approveApplication**

##### **语法:** public void approveApplication()

##### **前置条件:** 获取了所有的申请单据

##### **后置条件:** 更新申请单据的状态

**3. Approve.sendMessage**

##### **语法:** public void sendMessage()

##### **前置条件:** 单据审批通过

##### **后置条件:** 给库存管理员发送一条审批通过的消息

**4. Approve.endApplication**

##### **语法:** public void endPromotion()

##### **前置条件:** 已经完成了单据的审批

##### **后置条件:** 结束此次审批单据的回合

**需要的服务<需接口>** 

|                   服务名                    |     服务      |
| :--------------------------------------: | :---------: |
|       ApproveDataService.findAll()       |  查找全部持久化对象  |
| ApproveDataService.update(ApplicationPo applicationPo) |  更新单一持久化对象  |
| ApproveMessageDataService.insert(String message) | 在数据库中插入一条消息 |
|  ApproveMessageDataServicefind(int id)   |  查找最新的一条消息  |
|    ApproveMessageDataService.count()     | 统计一共有多少条消息  |

（4）业务逻辑层的动态模型

![Approve_getApplication顺序图](..\img\Approve_getApplication顺序图.png)

![Approve_approveApplication顺序图](..\img\Approve_approveApplication顺序图.png)

![Approve_sendMessage顺序图](..\img\Approve_sendMessage顺序图.png)

![Approve状态图](..\img\Approve状态图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.17 userbl

（1）模块概述

userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

userbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.userblservice.UserBLService接口。业务逻辑层和数据层之间添加dataservice.userdataservice.UserDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了UserController,这样UserController会将对销售的业务逻辑处理委托给User对象。UserPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表userbl 模块各个类的职责

|       模块        |                职责                 |
| :-------------: | :-------------------------------: |
| LoginController |         负责实现对应于登陆界面所需要的服务         |
|  UserConroller  |         负责实现账户管理界面所需要的服务          |
|      User       | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |

（3）模块内部类的接口规范

![user模块各个类的设计](..\img\user模块各个类的设计.png)

##### UserConroller模块的接口规范

**提供的服务<供接口>**

##### **1. UserConroller.login**

##### **语法:**public ResultMessage login(long id, String password)

##### **前置条件:** 已创建一个User领域对象，并且符合输入规则

##### **后置条件:** 调用User领域对象的login方法

##### **2. UserConroller.new**

##### **语法:**public UserVo new(long id, String password, int level,Usertype type)

##### **前置条件:** 已创建一个User领域对象，并且符合输入规则

##### **后置条件:** 调用User领域对象的new方法

##### **3. UserConroller.delete**

##### **语法:**public ResultMessage delete(long id)

##### **前置条件:** 已创建一个User领域对象，并且存在此id对象

##### **后置条件:** 调用User领域对象的delete方法

**需要的服务<需接口>** 

|                   服务名                    |  服务  |
| :--------------------------------------: | :--: |
|   User.login(long id, String password)   | 用户登录 |
| User.new(long id, String password, int level,Usertype type) | 新建用户 |
|           User.delete(long id)           | 删除用户 |

##### userbl模块的接口规范

**提供的服务<供接口>**

##### **1. User.login**

##### **语法:**public ResultMessage login(long id, String password)

##### **前置条件:** password符合输入规则

##### **后置条件:** 查找是否存在相应的User,根据输入的password返回登陆验证的结果

##### **2. User.new**

##### **语法:**public UserVo new(long id, String password, int level,Usertype type)

##### **前置条件:** id符合规范，password符合输入规则，level符合输入范围,type符合输入规范

##### **后置条件:** 创建一个用户名为id密码为password等级为level类型为type的新用户

##### **3. User.delete**

##### **语法:**public ResultMessage delete(long id)

##### **前置条件:** 存在此id的用户

##### **后置条件:** 将此用户标记为“已移除”

**需要的服务<需接口>** 

|                服务名                |       服务        |
| :-------------------------------: | :-------------: |
|  UserDataService.find(String id)  | 根据id进行查找单一持久化对象 |
| UserDataService.insert(UserPo po) |    插入单一持久化对象    |
| UserDataService.delete(UserPo po) |    删除单一持久化对象    |
| UserDataService.update(UserPo po) |    更新单一持久化对象    |

（4）业务逻辑层的动态模型

![新建用户的顺序图](..\img\新建用户的顺序图.png)

![删除用户的顺序图](..\img\删除用户的顺序图.png)

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

## 5. 依赖视角

![进销存管理系统客户端开发包图](..\img\进销存管理系统客户端开发包图.png)

![进销存管理系统服务器端开发包图](..\img\进销存管理系统服务器端开发包图.png)