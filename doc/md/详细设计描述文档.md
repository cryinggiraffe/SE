# 进销存管理系统软件详细设计描述文档

## 1. 引言

（蒲瑜琪写1——3部分）

### 1.1 编制目的

### 1.2 词汇表

### 1.3 参考资料

## 2. 产品概述

## 3. 体系结构设计概述

## 4. 结构视角

### 4.1 业务逻辑层的分解 

//以下4.1.0为示例 自己仿照着写自己的部分

______



#### 4.1.0 salebl 模块

（1）模块概述



（2）整体结构

- 表salebl 模块各个类的职责

|  模块  |  职责  |
| :--: | :--: |
|      |      |
|      |      |
|      |      |

（3）模块内部类的接口规范



**SalesController的接口规范**

**1.SalesController.addMenmber**

**语法：**

**前置条件：**

**后置条件：**

**2. SalesController.addCommodity**

**语法：**

**前置条件：**

**后置条件：**

......

**需要的服务（需接口）**

| 服务名  |  服务  |
| :--: | :--: |
|      |      |



（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

_______

以下就大家各自填写吧~

### 4.1.1 categorybl



### 4.1.2 goodbl



### 4.1.3 viewbl



### 4.1.4 giftbl



### 4.1.5 supervisebl



### 4.1.6 clientbl



### 4.1.7 importbl



### 4.1.8 salebl



### 4.1.9 financebl



### 4.1.10 accountbl

（1）模块概述

accountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

accountbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.accountblservice.AccountBLService接口。业务逻辑层和数据层之间添加dataservice.accountdataservice.AccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了AccountController,这样AccountController会将对销售的业务逻辑处理委托给Account对象。AccountPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表accountbl 模块各个类的职责

|        模块        |                    职责                    |
| :--------------: | :--------------------------------------: |
| LoginController  |            负责实现对应于登陆界面所需要的服务             |
| AccountConroller |             负责实现账户管理界面所需要的服务             |
|       User       |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|     Account      | 账户管理的领域模型对象，拥有账户名称、余额信息，可以帮助完成账户管理界面所需要的服务。 |

（3）模块内部类的接口规范

[ ^-^ ]: 此处缺张图

**AccountController的接口规范**

**提供的服务<供接口>**

##### **1. AccountController.addAccount**

##### **语法:**public ResultMessage addAccount(AccountVO avo)

##### **前置条件:** 已创建一个Account领域对象，并且符合输入规则

##### 后置条件: 调用Account领域对象的addAccount方法

##### **2. AccountController.delAccount**

##### **语法:**publicb ResultMessage delAccount(String name)

##### **前置条件:**已创建一个Account领域对象，且账户name存在

##### **后置条件:**调用Account领域对象的delAccount方法

##### **3. AccountController.findAccount**

##### **语法:**public AccountVO[] findAccount(String name)

##### **前置条件:**已创建一个Account领域对象,且查询账户name存在

##### **后置条件:**调用Account领域对象的findAccount方法

##### **4. AccountController.updateAccount**

##### **语法:**public ResultMessage updateAccount(AccountVO avo)

##### **前置条件:**已创建一个Account领域对象，并且符合输入规则

##### **后置条件:**调用Account领域对象的updateAccount方法

**需要的服务<需接口>** 

|                 服务名                  |   服务   |
| :----------------------------------: | :----: |
|  Account.addAccount(AccountVO avo)   | 加入一个账户 |
|   Account.delAccount(String name)    | 删除指定账户 |
|   Account.findAccount(String name)   | 查找指定账户 |
| Account.updateAccount(AccountVO avo) | 修改账户信息 |

**Account的接口规范**

**提供的服务<供接口>**

##### **1. Account.addAccount**

##### **语法:**public ResultMessage addAccount(AccountVO avo)

##### **前置条件:**启动一个新建账户事件

##### **后置条件:**成功添加账户信息

##### **2. Account.delAccount**

##### **语法:**publicb ResultMessage delAccount(String name)

##### **前置条件:**账户name存在

##### **后置条件:**成功删除账户信息

##### **3. Account.findAccount**

##### **语法:**public AccountVO[] findAccount(String name)

##### **前置条件:**查询账户name存在

##### **后置条件:**返回对应name账户信息

##### **4. Account.updateAccount**

##### **语法:**public ResultMessage updateAccount(AccountVO avo)

##### **前置条件:**修改值合法

##### **后置条件:**账户信息修改成功

**需要的服务<需接口>** 

|                   服务名                   |       服务        |
| :-------------------------------------: | :-------------: |
|  AccountDataService.find(String name)   | 根据名称进行查找单一持久化对象 |
| AccountDataService.insert(AccountPo po) |    插入单一持久化对象    |
| AccountDataService.delete(AccountPo po) |    删除单一持久化对象    |
| AccountDataService.update(AccountPo po) |    更新单一持久化对象    |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.11 billbl

（1）模块概述

billbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

billbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.billblservice.BillBLService接口。业务逻辑层和数据层之间添加dataservice.billdataservice.BillDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BillController,这样BillController会将对销售的业务逻辑处理委托给Bill对象。BillPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表billbl 模块各个类的职责

|       模块        |                    职责                    |
| :-------------: | :--------------------------------------: |
| LoginController |            负责实现对应于登陆界面所需要的服务             |
|  BillConroller  |             负责实现财务管理界面所需要的服务             |
|      User       |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|      Bill       | 财务管理的领域模型对象，拥有财务类数据的单据编号、操作员、清单、总额等，可以帮助完成财务管理界面所需要的服务。 |

（3）模块内部类的接口规范

[ ^-^ ]: 此处缺张图

##### BillController模块的接口规范

##### **提供的服务<供接口>**

##### 1. BillController.newReceipt

##### **语法:**public ResultMessage newReceipt(ReceiptVO rvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:** 调用Bill领域对象的newReceipt方法

##### **2.BillController.newPayment**

##### **语法:**public ResultMessage newPayment(PaymentVO pvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:**调用Bill领域对象的newPayment方法

##### **3. BillController.newCash**

##### **语法:**public ResultMessage newCash(CashVO cvo)

##### **前置条件:**已创建一个Bill领域对象，并且符合输入规则

##### **后置条件:**现金费用单创建成功

**4. BillController.changeState**

##### **语法:**public ResultMessage changeState(String id)

##### **前置条件:** 已创建一个Bill领域对象，且查询id存在

##### **后置条件:** 调用Bill领域对象的changeState方法

**需要的服务<需接口>** 

|              服务名               |   服务    |
| :----------------------------: | :-----: |
| Bill.newReceipt(ReceiptVO rvo) |  创建收款单  |
| Bill.newReceipt(PaymentVO pvo) |  创建付款单  |
|    Bill.newCash(CashVO cvo)    | 创建现金费用单 |
|  Bill.changeState(String id)   | 修改单据状态  |

##### billbl模块的接口规范

##### **提供的服务<供接口>**

##### 1. Bill.newReceipt

##### **语法:**public ResultMessage newReceipt(ReceiptVO rvo)

##### **前置条件:**启动一个生成收款单事件

##### **后置条件:**收款单创建成功

##### **2. Bill.newReceipt**

##### **语法:**public ResultMessage newPayment(PaymentVO pvo)

##### **前置条件:**启动一个生成付款单事件

##### **后置条件:**付款单创建成功

##### **3. Bill.newCash**

##### **语法:**public ResultMessage newCash(CashVO cvo)

##### **前置条件:**启动一个生成现金费用单事件

##### **后置条件:**现金费用单创建成功

**4. Bill.changeState**

##### **语法:**public ResultMessage changeState(String id)

##### **前置条件:** 单据Id合法

##### **后置条件:** 将该单据的审批状态改为待审批

**需要的服务<需接口>** 

|                服务名                |    服务     |
| :-------------------------------: | :-------: |
| BillDataService.insert(BillPo po) | 插入单一持久化对象 |
| BillDataService.delete(BillPo po) | 删除单一持久化对象 |
| BillDataService.update(BillPo po) | 更新单一持久化对象 |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.12 initialAccountbl

（1）模块概述

initialAccountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

initialAccountbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.initialAccountblservice.InitialAccountBLService接口。业务逻辑层和数据层之间添加dataservice.initialAccountdataservice.InitialAccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了InitialAccountController,这样InitialAccountController会将对销售的业务逻辑处理委托给InitialAccount对象。InitialAccountPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表initialAccountbl 模块各个类的职责

|           模块            |                    职责                    |
| :---------------------: | :--------------------------------------: |
|     LoginController     |            负责实现对应于登陆界面所需要的服务             |
| InitialAccountConroller |             负责实现期初建账界面所需要的服务             |
|          User           |    系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题     |
|     InitialAccount      | 期初建账的领域模型对象，拥有期初建账数据的商品信息、最近进价和最近售价、客户信息、银行账户信息，可以帮助完成期初建账界面所需要的服务。 |

（3）模块内部类的接口规范

[ ^-^ ]: 此处缺张图

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.13 businessProcessbl

（1）模块概述

businessProcessbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

businessProcessbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.businessProcessblservice.BusinessProcessBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BusinessProcessController,这样BusinessProcessController会将对销售的业务逻辑处理委托给BusinessProcess对象。

- 表salebl 模块各个类的职责

|            模块            |                职责                 |
| :----------------------: | :-------------------------------: |
|     LoginController      |         负责实现对应于登陆界面所需要的服务         |
| BusinessProcessConroller |        负责实现经营历程查询界面所需要的服务         |
|           User           | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     BusinessProcess      | 账户管理的领域模型对象，可以帮助完成经营历程查询界面所需要的服务。 |

（3）模块内部类的接口规范

[ ^-^ ]: 此处缺张图

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 4.1.14 translationSituationbl

（1）模块概述

translationSituationbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

translationSituationbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.translationSituationblservice.TranslationSituationBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了TranslationSituationController,这样TranslationSituationController会将对销售的业务逻辑处理委托给TranslationSituation对象。

- 表translationSituationbl 模块各个类的职责

|               模块                |                职责                 |
| :-----------------------------: | :-------------------------------: |
|         LoginController         |         负责实现对应于登陆界面所需要的服务         |
| TranslationSituationblConroller |        负责实现经营情况查询界面所需要的服务         |
|              User               | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     TranslationSituationbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

（3）模块内部类的接口规范

 ^-^ 此处缺张图

##### TranslationSituationController模块的接口规范

##### **提供的服务<供接口>**

**1.TranslationSituationController.query**

##### **语法:** public ResultMessage query()

##### **前置条件:**  已创建一个TranslationSituation领域对象

##### **后置条件:**  显示交易情况

**2.TranslationSituationController.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 调用TranslationSituation领域对象的end方法

**需要的服务<需接口>** 

|            服务名             |      服务      |
| :------------------------: | :----------: |
| TranslationSituation.query | 查询一段时间内的经营情况 |
|  TranslationSituation.end  |   结束此次查询回合   |

##### TranslationSituation 模块的接口规范

##### **提供的服务<供接口>**

**1.TranslationSituation.query**

##### **语法:** public ResultMessage query()

##### **前置条件:**  无

##### **后置条件:**  显示交易情况

**2.TranslationSituation.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 结束此次查询回合

**需要的服务<需接口>** 

|                   服务名                    |    服务     |
| :--------------------------------------: | :-------: |
|        SaleDataService.findAll()         | 查找所有持久化对象 |
| TranslationSituationDataService.findAll() | 查找所有持久化对象 |
|       ImportDataService.findAll()        | 查找所有持久化对象 |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.15 saleSituationbl

（1）模块概述

saleSituationbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

saleSituationbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.saleSituationblservice.SaleSituationBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SaleSituationController,这样SaleSituationController会将对销售的业务逻辑处理委托给SaleSituation对象。

- 表saleSituationbl模块各个类的职责

|            模块            |                职责                 |
| :----------------------: | :-------------------------------: |
|     LoginController      |         负责实现对应于登陆界面所需要的服务         |
| SaleSituationblConroller |        负责实现经营情况查询界面所需要的服务         |
|           User           | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     SaleSituationbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

**SaleSituationController模块的接口规范**

##### **提供的服务<供接口>**

**1.SaleSituationController.query**

##### **语法:** public List<SaleSituation> query(SaleSituationVo saleSituationVo)

##### **前置条件:**  已创建了一个SaleSituation领域对象，并且输入符合输入规则

##### **后置条件:**  调用SaleSituation领域对象的query方法

**2.SaleSituationController.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 调用SaleSituation领域对象的end方法

**需要的服务<需接口>** 

|         服务名         |      服务      |
| :-----------------: | :----------: |
| SaleSituation.query | 查询一段时间内的经营情况 |
|  SaleSituation.end  |   结束此次查询回合   |

##### 

##### SaleSituation 模块的接口规范

##### **提供的服务<供接口>**

**1.SaleSituation.List**

##### **语法:** public List<SaleSituation> query(SaleSituationVo saleSituationVo)

##### **前置条件:**  查询条件合法

##### **后置条件:**  显示符合条件的销售明细

**2.SaleSituation.end**

##### **语法:** public ResultMessage end()

##### **前置条件:**  完成经营历程的查询

##### **后置条件:** 结束此次查询回合

**需要的服务<需接口>** 

|                   服务名                    |       服务       |
| :--------------------------------------: | :------------: |
|        SaleDataService.findAll()         |   查找所有持久化对象    |
| SaleSituationDataService.findForList(SaleSituationVo saleSituationVo) | 查找所有符合条件的持久化对象 |
|        BillDataService.findAll()         |   查找所有持久化对象    |
|       ImportDataService.findAll()        |   查找所有持久化对象    |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.16 promotionbl

（1）模块概述

promotionbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

promotionbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.promotionblservice.PromotionBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PromotionController,这样PromotionController会将对销售的业务逻辑处理委托给Promotion对象。

- 表translationSituationbl 模块各个类的职责

|          模块          |                职责                 |
| :------------------: | :-------------------------------: |
|   LoginController    |         负责实现对应于登陆界面所需要的服务         |
| PromotionblConroller |        负责实现经营情况查询界面所需要的服务         |
|         User         | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|     Promotionbl      | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

**PromotionController模块的接口规范**

##### **提供的服务<供接口>**

**1.PromotionController.makePromotion**

##### **语法:** public ResultMessage makePromotion(PromotionVO promotionVo)

##### **前置条件:**  已创建了一个Promotion领域对象，启动一个制定促销策略回合

##### **后置条件:**  调用Promotion领域对象的makePromotion方法

**2.PromotionController.endPromotion**

##### **语法:** public ResultMessage endPromotion()

##### **前置条件:**  已经制定了一个销售策略

##### **后置条件:** 调用Promotion领域对象的end方法

**需要的服务<需接口>** 

|           服务名           |      服务      |
| :---------------------: | :----------: |
| Promotion.makePromotion |    制订销售策略    |
| Promotion.endPromotion  | 结束此次制订销售策略过程 |

##### Promotion 模块的接口规范

**提供的服务<供接口>**

**1. Promotion.makePromotion**

##### **语法:**public ResultMessage makePromotion(PromotionVO promotionVo)

##### **前置条件:**启动一个制定促销策略回合

##### **后置条件:**成功制定促销策略，持久化更新涉及的领域对象的数据

**2. Promotion.endPromotion**

##### **语法:** public void endPromotion()

##### **前置条件:** 已经制定了一个销售策略

##### **后置条件:** 结束此次制定促销策略回合

**需要的服务<需接口>** 

|                   服务名                    |    服务     |
| :--------------------------------------: | :-------: |
| PricePromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| PricePromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| PricePromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
|   PricePromotionDataService.findAll()    | 查找全部持久化对象 |
| CommodityPromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| CommodityPromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| CommodityPromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
| CommodityPromotionDataService.finaAll()  | 查找全部持久化对象 |
| UserClassPromotionDataService.insert(PromotionPO promotionPO) | 插入单一持久化对象 |
| UserCalssPromotionDataService.delete(PromotionPO promotionPO) | 删除单一持久化对象 |
| UserClassPromotionDataService.update(PromotionPO promotionPO) | 更新单一持久化对象 |
| UserClassPromotionDataService.findAll()  | 查找全部持久化对象 |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。



### 4.1.17 approvebl

（1）模块概述

approvebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

approvebl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.approveblservice.ApproveblBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了ApproveblController,这样ApproveblController会将对销售的业务逻辑处理委托给Approvebl对象。

- 表approvebl 模块各个类的职责

|         模块         |                职责                 |
| :----------------: | :-------------------------------: |
|  LoginController   |         负责实现对应于登陆界面所需要的服务         |
| ApproveblConroller |        负责实现经营情况查询界面所需要的服务         |
|        User        | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
|    Approveblbl     | 账户管理的领域模型对象，可以帮助完成经营情况查询界面所需要的服务。 |

**ApproveController模块的接口规范**

##### **提供的服务<供接口>**

**1.ApproveController.getApplication**

##### **语法:** public void getApplication()

##### **前置条件:** 已创建一个Approve领域对象，启动一个审批单据的回合

##### **后置条件:** 调用Approve领域对象的getApplication方法

**2. ApproveController.approveApplication**

##### **语法:** public void approveApplication()

##### **前置条件:** 已创建一个Approve领域对象，获取了所有的申请单据

##### **后置条件:** 调用Approve领域对象的approveApplication方法

**3. ApproveController.sendMessage**

##### **语法:** public void sendMessage()

##### **前置条件:** 已创建一个Approve领域对象，单据审批已通过

##### **后置条件:** 调用Approve领域对象的sendMessage方法

**4. ApproveController.endApplication**

##### **语法:** public void endPromotion()

##### **前置条件:** 已创建一个Approve领域对象

##### **后置条件:** 调用Approve领域对象的endApplication

**需要的服务<需接口>** 

|            服务名             |        服务         |
| :------------------------: | :---------------: |
|   Approve.getApplication   |    得到所有的审批状态单据    |
| Approve.approveApplication |       审批单据        |
|    Approve.sendMessage     | 给库存管理员发送一条审批通过的消息 |
|   Approve.endApplication   |    结束此次审批单据的回合    |

##### 

**Approve 模块的接口规范**

**提供的服务<供接口>**

**1.Approve.getApplication**

##### **语法:** public void getApplication()

##### **前置条件:** 启动一个审批单据的回合

##### **后置条件:** 返回所有申请单据

**2. Approve.approveApplication**

##### **语法:** public void approveApplication()

##### **前置条件:** 获取了所有的申请单据

##### **后置条件:** 更新申请单据的状态

**3. Approve.sendMessage**

##### **语法:** public void sendMessage()

##### **前置条件:** 单据审批通过

##### **后置条件:** 给库存管理员发送一条审批通过的消息

**4. Approve.endApplication**

##### **语法:** public void endPromotion()

##### **前置条件:** 已经完成了单据的审批

##### **后置条件:** 结束此次审批单据的回合

**需要的服务<需接口>** 

|                   服务名                    |     服务      |
| :--------------------------------------: | :---------: |
|       ApproveDataService.findAll()       |  查找全部持久化对象  |
| ApproveDataService.update(ApplicationPo applicationPo) |  更新单一持久化对象  |
| ApproveMessageDataService.insert(String message) | 在数据库中插入一条消息 |
|  ApproveMessageDataServicefind(int id)   |  查找最新的一条消息  |
|    ApproveMessageDataService.count()     | 统计一共有多少条消息  |

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

### 

### 4.1.18 userbl

（1）模块概述

userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

userbl模块的职责及接口参见软件系统结构描述文档。

（2）整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们将添加businesslogicservice.userblservice.UserBLService接口。业务逻辑层和数据层之间添加dataservice.userdataservice.UserDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了UserController,这样UserController会将对销售的业务逻辑处理委托给User对象。UserPO是作为账户记录的持久化对象被添加到设计模型中去的。

- 表salebl 模块各个类的职责

|       模块        |                职责                 |
| :-------------: | :-------------------------------: |
| LoginController |         负责实现对应于登陆界面所需要的服务         |
|  UserConroller  |         负责实现账户管理界面所需要的服务          |
|      User       | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |

（3）模块内部类的接口规范

[ ^-^ ]: 此处缺张图

（4）业务逻辑层的动态模型

自己画图插进来

（5）业务逻辑层的设计原理

利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

## 5. 依赖视角

![进销存管理系统客户端开发包图](..\img\进销存管理系统客户端开发包图.png)

![进销存管理系统服务器端开发包图](..\img\进销存管理系统服务器端开发包图.png)